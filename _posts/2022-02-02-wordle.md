---
layout: post
title: A Python Wordle Clone
categories: [blog]
---

When learning how to program, I always recommend having a project or application in mind. For me, it makes it easier to concentrate and learn specific skills and flex the critical thinking muscle. What better project to attempt than the latest game craze, [Wordle](https://www.powerlanguage.co.uk/wordle/)? In this post-essay, I'll take you through the steps required to write your own version of Wordle on the command-line.

To make it even more fun (and of course, a tad embarassing for me), I screen-captured myself programming wordle, unedited, for those interested in watching.

<!--more-->

## Structure

This post-essay will take you through the steps and components required to program a Worldle clone in Python (on the command-line, without a GUI), and we'll use this as a use case for what is required to build a medium-sized project. Some parts will be quite boring (for example, planning and gathering requirements), but I hope to use this as a use case to showcase what kinds of work software developers do every day.

First, we'll go through the requirements of our project (the Wordle clone) and put them into a list. Next, we'll tackle each item one by one. Feel free to skip around!

* stuff
{:toc}

## Requirements

Before starting any programming project, it is important to make a list of all the features you want it to have. This accomplishes two things: (1) gives you a "stopping point" to know when you're done, and (2) lets you organize your thoughts to make sure your choices for how to implement cover all your use cases.

In our case, for a Python command-line clone of Wordle, here is our requirements and features list:

### Gameplay

* Game randomly selects a single 5-letter word from a word list to use as the "game word".
* The word length is taken from the game word, rather than being hard-coded at 5 letters.
* Command-line display asking player to enter guesses.
* A guess is only valid if it is the same length as the game word.
* All guesses should come from a word list. If the guess is not from the list, tell the player, and don't accept the word as part of the number of guesses.
* The player can enter words either in capital or lowercase.
* To quit the game early, the player should press CTRL-C. _The reasoning behind this choice (rather than, for example, having the player type "quit" or "Q") is that CTRL-C can never be a guessed word, whereas "quit" can be. This means that modifying the game to work with 4-letter words does not break the core game play._
* The game will keep track of how many guesses the player has done and display that at the end, either when the word is guessed or when the game is quit.

### Rules

* A guessed letter that is correct and in the correct place displays a `*`.
* A guessed letter that is correct but in the incorrect place displays a `-`.
* All other guessed letters are returned with a blank `_`.
* When the game word has two of the same letter, but the guessed word has one of that letter, it follows the rules for correct and incorrect placement.
* Correctly guessed letters in the correct place are displayed first.
* If the game word has one of a letter, but the guessed word has two, both in the wrong place, only the first letter in the guessed word is displayed as `-`.
* If the game word has one of a letter, but the guessed word has two, one in the correct place, the correct letter is displayed as `*` and the second copy of the letter is unmarked.

## Basic Design

For any command-line game, the basic program structure is a large infinite `while` loop that keeps "playing the game" until an end condition is met. According to our requirements list, the end conditions are:

1. The player guesses the word correctly.
2. The player exits by pressing CTRL-C.

So the first step is to structure our program with this basic scaffold (in a `__main__` block). First we tackle the first condition. We don't deal with selecting the word or processing guesses, so we create two dummy variables (`WORD` and `GUESS`), set them to specific strings, and continue adding on later.

{% highlight python %}
if __name__ == '__main__':
  WORD = "TESTS"
  while True:
    GUESS = "PHONE"
    if WORD == GUESS:
      print("You won!")
      break
{% endhighlight %}

Now we can add in the second end condition (exit on CTRL-C). This is slightly more complicated, since in Python the way to catch a CTRL-C press is through a `KeyboardInterrupt` exception, so we wrap the existing loop in a `try`/`catch` to catch the CTRL-C.

{% highlight python %}
if __name__ == '__main__':
  WORD = "TESTS"

  try:
    while True:
      GUESS = "PHONE"
      if WORD == GUESS:
        print("You won!")
        break
  except KeyboardInterrupt:
    print("You exited the game.")
{% endhighlight %}

Now that we have the structure of the main loop, we can add in the mechanics for player interaction, namely, taking player guesses.

## Player Guesses

One feature of the game play is that we need some error checking / handling on a player's guesses. Because this is a functionality that can be independently tested and verified, processing and getting a user guess is a great candidate for putting inside of a function. The heading of this function will look like this:

{% highlight python %}
def get_user_guess(wordlen: int, dictionary: list[str]) -> str:
    """Get a user guess input, validate, and return the guess."""
{% endhighlight %}

The type annotation is natively supported in Python 3, as seen in the [official documentation for the `typing` library](https://docs.python.org/3.9/library/typing.html). What our function signature tells us is that the function is going to get the user guess. It takes in two inputs: (1) the length of the expected game word (which is an int), and (2) the list of available guess words as strings. The function will return a single string, which is the player's guess. Because we return the string of the guess from this function, all the logic around validating a guess, displaying to the player why the guess is in valid, and asking the user to input a new guess, is contained in this function. Because we are potentially in a situation where we need to ask the user multiple times to enter a guess (if for example they keep entering a 4-letter word when the game word is 5 letters), we use another `while` loop here for the structure.

{% highlight python %}
def get_user_guess(wordlen: int, dictionary: list[str]) -> str:
    """Get a user guess input, validate, and return the guess."""
    # continue looping until you get a valid guess
    while True:
        guess = input("Guess: ")
        # here we overwrite guess with
        # the filtered guess
        error, guess = validate(guess=guess, wordlen=wordlen,
                                dictionary=dictionary)

        # if there wasn't an error with the guess, we stop asking
        # the user for new guesses
        if error is None:
            break

        # show the input error to the user, as appropriate
        print(error)
    return guess
{% endhighlight %}

The choice I've made here is to abstract the "validation" logic into yet another function. This is because validating a guess is a repeatable action we take on a word that can be independently tested. Let's write that validation function now:

{% highlight python %}
def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
{% endhighlight %}

Our validation function header will validate a guess according to any validation rules we want. It takes in a guess as a string (any string), the expected length of the game word, and the list of possible game words. What the validation function returns is a tuple containing the error and the guess word. If there is no error, `None` is returned for the error. This is again a design choice - some programmers will not return the guess word back, and rely on the fact that if `None` is returned for the error, the initial guess word is fine. However, the choice here of returning the guess word is a form of filtering & validation. Because we listed in the requirements that guesses can be entered in uppercase or lower case, we want to standardize all the guesses into uppercase. This means that somewhere we will have to convert the guess into all uppercase letters. What better place to do this than the same function where we are validating our guesses?

The implementation of the function then looks like this:

{% highlight python %}
def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
    # make sure the guess is all upper case. but don't modify
    # the passed-in guess, since Python input variables are global
    guess_upper = guess.upper()
    # guesses must be the same as the input word
    if len(guess_upper) != wordlen:
        return f"Guess must be of length {wordlen}", guess_upper

    # guesses must also be words from the word list
    if guess_upper not in dictionary:
        return "Guess must be a valid word", guess_upper
    return None, guess_upper
{% endhighlight %}

Note that all the return statements return a tuple: the first argument is an error string (or `None` if we get all the way to the end), and the guess converted into uppercase.

Of note: Python variables are passed _by reference_, which means that if an input argument to a function is modified, the variable that is passed in is also modified. This can have unintended consequences for the code that is calling a function, so to prevent any side effects on the calling code, we convert the `guess` variable to uppercase and store it in a new variable called `guess_upper`, rather than doing `guess = guess.upper()`.

Now that we have a validation function, a user input function, and a main loop, our code so far looks like:

{% highlight python %}
import typing


def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
    # make sure the guess is all upper case. but don't modify
    # the passed-in guess, since Python input variables are global
    guess_upper = guess.upper()
    # guesses must be the same as the input word
    if len(guess_upper) != wordlen:
        return f"Guess must be of length {wordlen}", guess_upper

    # guesses must also be words from the word list
    if guess_upper not in dictionary:
        return "Guess must be a valid word", guess_upper
    return None, guess_upper


def get_user_guess(wordlen: int, dictionary: list[str]) -> str:
    """Get a user guess input, validate, and return the guess."""
    # continue looping until you get a valid guess
    while True:
        guess = input("Guess: ")
        # here we overwrite guess with
        # the filtered guess
        error, guess = validate(guess=guess, wordlen=wordlen,
                                dictionary=dictionary)

        # if there wasn't an error with the guess, we stop asking
        # the user for new guesses
        if error is None:
            break

        # show the input error to the user, as appropriate
        print(error)
    return guess

if __name__ == '__main__':
  WORD = "TESTS"
  GAME_WORD_LENGTH = len(WORD)
  GUESS_DICTIONARY = [WORD, "GAMES", "FRONT", "TILES"]

  try:
    while True:
      GUESS = get_user_guess(GAME_WORD_LENGTH, GUESS_DICTIONARY)

      if WORD == GUESS:
        print("You won!")
        break
  except KeyboardInterrupt:
    print("You exited the game.")
{% endhighlight %}

At this point, we have a game where player input is continually read and validated! Next up, displaying information back to the player so the game is actually fun!

## Displaying Guesses

Now we get to an interesting coding step: we need to take the guess that we have taken from the user, parse it, and display the information back to the user in a way that makes the game fun. There are two types of information that can be displayed back to the user: guessed letters in the correct place, and guessed letters in the incorrect place. We implement these in that order, to make sure we got it right!

Like always, we start with the function signature:

{% highlight python %}
def compare(correct: str, guess: str) -> typing.List[str]:
    """Compare the guess with the correct word and return the output parse."""
{% endhighlight %}

What we'll do is take in the `correct` game word as a string, and the (parsed and validated) `guess` word as a string. This function will do all the character comparison, and output a list of strings denoting the state of each letter in the guess. Per our requirements set up in the previous section, the characters in the output mean the following: (a) `_` is a blank - no information is known about this letter; (b) `*` is a guessed letter is in the correct place in the game word; (c) `-` is a guessed letter that is correct but in the incorrect place in the game word.

We return this parsed list with symbols rather than do the printing directly in this function to separate concerns. If we ever want to change how the display is done in the command-line (for example, add emojis, or add colors, etc.) then we can use the returned parsed list to generate an output.

The first step in writing the function is to set up the output, and we will tackle the easier part of answer parsing: characters in the guessed word that are in the correct place in the game word.

Since this is a tricky function in the Wordle implementation, and the one that most directly affects gameplay, let's start with a set of test cases that we can call on our function to make sure we have all the cases right!

| Function call | Expected Output |
|---|---|
| `compare("steer", "stirs")` | `* * _ - _` |
| `compare("steer", "floss")` | `_ _ _ - _` |
| `compare("pains", "stirs")` | `_ _ * _ *` |
| `compare("creep", "enter")` | `- _ _ * -` |
| `compare("crape", "enter")` | `- _ _ _ -` |
| `compare("ennui", "enter")` | `* * _ _ _` |

These test cases cover a range of outputs and cases that we expect this function to accomplish, both "normal" behavior and a few edge cases that are tricky. What we're doing here is a miniature version of a software engineering concept called Test Driven Development (TDD). In TDD, the idea is that before you actually write your code, you think about how you are going to test your code, and oftentimes, write the tests first. That way, the verification for "does my code do what it needs to" is already done.

So, let's begin! First we implement the logic for checking whether guessed characters are in the correct place. This is done (per the rules requirements above) first before the other characters, and those correctly-guessed letters cannot be double-counted. Here is our implementation:

{% highlight python %}
def compare(correct: str, guess: str) -> typing.List[str]:
    """Compare the guess with the correct word and return the output parse."""
    # the output is assumed to be incorrect to start,
    # and as we progress through the checking, update
    # each position in our output list
    output = ["_"] * len(correct)

    # first we check for correct words in the correct positions
    # and update the output accordingly
    for index, (correct_char, guess_char) in enumerate(zip(correct, guess)):
        if correct_char == guess_char:
            # a correct character in the correct position
            output[index] = "*"
    # return the list of parses
    return output
{% endhighlight %}

At this point if we call this function with our test cases, we will see that we correctly mark the correctly-guessed characters!

| Function call | Output so far |
|---|---|
| `compare("steer", "stirs")` | `* * _ _ _` |
| `compare("steer", "floss")` | `_ _ _ _ _` |
| `compare("pains", "stirs")` | `_ _ * _ *` |
| `compare("creep", "enter")` | `_ _ _ * _` |
| `compare("crape", "enter")` | `_ _ _ _ _` |
| `compare("ennui", "enter")` | `* * _ _ _` |

Now we move on to the more challenging part: checking for guessed letters that are in the correct place. The way we are going to do this is as follows:

* First account for all the letters guessed in the correct positions (done above)
* Keep track of all the character indices in the game word that have already been "accounted for" by letters from the guessed word. Add all the positions of correctly-guessed letters into this set.
* For each guessed character (excluding characters that have already been marked as correctly-positioned guesses), find all the corresponding indices in the game word for that character.
* If that position is already accounted for (i.e. is present in the set of accounted-for letters), keep checking for other positions of that character. Once you find a position that has not yet been accounted for, mark the guess with a `-`, add that position to the accounted-for set, and move on to the next guessed character.

Note that we have to introduce a new structure here to capture the game state: we need to keep track of which characters in the game word have been correctly identified in the game word (whether in the correct or incorrect positions). The reason for this is to take into account the potential for the game word and guess word to both have multiple characters. If there are multiple characters in the guess word, we only count their correct or incorrectness once. That is, if the game word has one "R" but the guess word has two "R"s, then we at most display information back to the user for a single "R" in the guess word (whether that is in the correct or incorrect place). Our test cases listed above cover these gameplay cases.

In this design, we need to write one helper function. Namely, we need to find all the positions of a given letter in the game word. There isn't any pre-built Python function to do this, so we need to build our own. We base our helper function on the built-in function [`.find()`](https://docs.python.org/3/library/stdtypes.html#str.find) that returns the first index of the desired character in the string. What we want is ALL the positions, so we wrap this function into a loop, and take advantage of the fact that we can specify where in the target word we can search for a character.

{% highlight python %}
def find_all_char_positions(word: str, char: str) -> typing.List[int]:
    """Given a word and a character, find all the indices of that character."""
    positions = []
    pos = word.find(char)
    while pos != -1:
        positions.append(pos)
        pos = word.find(char, pos + 1)
    # make sure the positions are all sorted lowest
    # to highest when this function returns
    return sorted(positions)
{% endhighlight %}

We make sure to return a sorted list of positions in the game word as a list of integers, since this is how we expect to use the output of this function for gameplay.

So with the `find_all_char_positions` function built, our code now looks like this:

{% highlight python %}
def compare(correct: str, guess: str) -> typing.List[str]:
    """Compare the guess with the correct word and return the output parse."""
    # the output is assumed to be incorrect to start,
    # and as we progress through the checking, update
    # each position in our output list
    output = ["_"] * len(correct)
    counted_pos = set()

    # first we check for correct words in the correct positions
    # and update the output accordingly
    for index, (correct_char, guess_char) in enumerate(zip(correct, guess)):
        if correct_char == guess_char:
            # a correct character in the correct position
            output[index] = "*"
            counted_pos.add(index)

    # now we check for the remaining letters that are in incorrect
    # positions. in this case, we need to make sure that if the
    # character that this is correct for was already
    # counted as a correct character, we do NOT display
    # this in the double case. e.g. if the correct word
    # is "steer" but we guess "stirs", the second "S"
    # should display "_" and not "-", since the "S" where
    # it belongs was already displayed correctly
    # likewise, if the guess word has two letters in incorrect
    # places, only the first letter is displayed as a "-".
    # e.g. if the guess is "floss" but the game word is "steer"
    # then the output should be "_ _ _ - _"; the second "s" in "floss"
    # is not displayed.
    for index, guess_char in enumerate(guess):
        # if the guessed character is in the correct word,
        # we need to check the other conditions. the easiest
        # one is that if we have not already guessed that
        # letter in the correct place. if we have, don't
        # double-count
        if guess_char in correct and \
                output[index] != "*":
            # first, what are all the positions the guessed
            # character is present in
            positions = find_all_char_positions(word=correct, char=guess_char)
            # have we accounted for all the positions
            for pos in positions:
                # if we have not accounted for the correct
                # position of this letter yet
                if pos not in counted_pos:
                    output[index] = "-"
                    counted_pos.add(pos)
                    # we only count the "correct letter" once,
                    # so we break out of the "for pos in positions" loop
                    break
    # return the list of parses
    return output
{% endhighlight %}

We choose a `set` as the data structure (in the `counted_pos` variable) for keeping track of the counted positions, since the ordering of the positions doesn't matter, and the most common operation we do on this structure is checking whether the variable `pos` is contained in it, which makes a `set` an appropriate data structure.

Now we can check against our test cases to confirm we got it right:

| Function call | Output |
|---|---|
| `compare("steer", "stirs")` | `* * _ - _` |
| `compare("steer", "floss")` | `_ _ _ - _` |
| `compare("pains", "stirs")` | `_ _ * _ *` |
| `compare("creep", "enter")` | `- _ _ * -` |
| `compare("crape", "enter")` | `- _ _ _ -` |
| `compare("ennui", "enter")` | `* * _ _ _` |

And there we go! A comparison function for parsing user guesses against a game word. Now we plug this into our main loop for some gameplay!

{% highlight python %}
import typing


def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
    # make sure the guess is all upper case. but don't modify
    # the passed-in guess, since Python input variables are global
    guess_upper = guess.upper()
    # guesses must be the same as the input word
    if len(guess_upper) != wordlen:
        return f"Guess must be of length {wordlen}", guess_upper

    # guesses must also be words from the word list
    if guess_upper not in dictionary:
        return "Guess must be a valid word", guess_upper
    return None, guess_upper


def get_user_guess(wordlen: int, dictionary: list[str]) -> str:
    """Get a user guess input, validate, and return the guess."""
    # continue looping until you get a valid guess
    while True:
        guess = input("Guess: ")
        # here we overwrite guess with
        # the filtered guess
        error, guess = validate(guess=guess, wordlen=wordlen,
                                dictionary=dictionary)

        # if there wasn't an error with the guess, we stop asking
        # the user for new guesses
        if error is None:
            break

        # show the input error to the user, as appropriate
        print(error)
    return guess


def find_all_char_positions(word: str, char: str) -> typing.List[int]:
    """Given a word and a character, find all the indices of that character."""
    positions = []
    pos = word.find(char)
    while pos != -1:
        positions.append(pos)
        pos = word.find(char, pos + 1)
    # make sure the positions are all sorted lowest
    # to highest when this function returns
    return sorted(positions)


def compare(correct: str, guess: str) -> typing.List[str]:
    """Compare the guess with the correct word and return the output parse."""
    # the output is assumed to be incorrect to start,
    # and as we progress through the checking, update
    # each position in our output list
    output = ["_"] * len(correct)
    counted_pos = set()

    # first we check for correct words in the correct positions
    # and update the output accordingly
    for index, (correct_char, guess_char) in enumerate(zip(correct, guess)):
        if correct_char == guess_char:
            # a correct character in the correct position
            output[index] = "*"
            counted_pos.add(index)

    # now we check for the remaining letters that are in incorrect
    # positions. in this case, we need to make sure that if the
    # character that this is correct for was already
    # counted as a correct character, we do NOT display
    # this in the double case. e.g. if the correct word
    # is "steer" but we guess "stirs", the second "S"
    # should display "_" and not "-", since the "S" where
    # it belongs was already displayed correctly
    # likewise, if the guess word has two letters in incorrect
    # places, only the first letter is displayed as a "-".
    # e.g. if the guess is "floss" but the game word is "steer"
    # then the output should be "_ _ _ - _"; the second "s" in "floss"
    # is not displayed.
    for index, guess_char in enumerate(guess):
        # if the guessed character is in the correct word,
        # we need to check the other conditions. the easiest
        # one is that if we have not already guessed that
        # letter in the correct place. if we have, don't
        # double-count
        if guess_char in correct and \
                output[index] != "*":
            # first, what are all the positions the guessed
            # character is present in
            positions = find_all_char_positions(word=correct, char=guess_char)
            # have we accounted for all the positions
            for pos in positions:
                # if we have not accounted for the correct
                # position of this letter yet
                if pos not in counted_pos:
                    output[index] = "-"
                    counted_pos.add(pos)
                    # we only count the "correct letter" once,
                    # so we break out of the "for pos in positions" loop
                    break
    # return the list of parses
    return output


if __name__ == '__main__':
  WORD = "TESTS"
  GAME_WORD_LENGTH = len(WORD)
  GUESS_DICTIONARY = [WORD, "GAMES", "FRONT", "TILES"]

  try:
    while True:
      # get the user to guess something
      GUESS = get_user_guess(
          wordlen=GAME_WORD_LENGTH, dictionary=GUESSWORD_DICTIONARY)

      # display the guess when compared against the game word
      result = compare(correct=WORD, guess=GUESS)
      print(" ".join(result))

      if WORD == GUESS:
        print("You won!")
        break
  except KeyboardInterrupt:
    print("You exited the game.")
{% endhighlight %}

And now we have a playable game!

## Generating the Wordlist

Of course, one "trick" we did with our implementation so far is hard-code the game word. This makes for a pretty boring game, so as the next step is to generate some word lists that are more fun!

There is "right way" to generate a word list. Because of a previous exercise on this blog, I had a local copy of [SOWPODS](https://www.wordgamedictionary.com/sowpods/), the official Scrabble word list, locally. However, as you know of Scrabble words, some are a bit obscure and not very fun for gameplay. Besides, SOWPODS has words of many lengths, whereas in our version of Wordle we wanted to limit only to 5-letter words.

The additional detail about word lists in Wordle is that there are actually _two_ word lists. One word list for game words (which has fewer words, and contains more "common" words), and a separate word list for validating guesses, which contains the game word list and a bunch of other more "obscure" words. I don't know for sure how the original implementor of Wordle generated these lists, but I have to assume some amount of hand-curation was done.

We on the other hand don't need to hand-curate our list (unless you want to for your own implementation). Instead, we look at the page source for Wordle and extract the lists from that code. We save these as two separate word lists (`gamewords.txt` and `guesswords.txt`) that we can load into our game. One helper function we will write (since it will be used twice, once for each list of words), is a `create_dictionary()` helper function that loads the word lists into a list and makes sure all the words are upper case.

We actually implement this as two functions: one for filtering/modifying words, and one for ingesting the word list in the first place. This is because if we ever want to expand the word lists to contain words of multiple lengths, we don't need to maintain separate word lists for all the lengths; we can simply put them in one list, and filter the random game/guess words in real time during game play.

First we implement a `filter_word()` function that takes in a word and any filtering criteria. It returns back the word modified (in our case converted to upper case). If we decide to add new functionality into our Wordle implementation (for example, limiting words to only start with "T" or something else), then that functionality would be added into this function.

{% highlight python %}
def filter_word(word: str, length: int) -> str:
    """Filter a word to add it to the dictionary."""
    if len(word.strip()) == length:
        # make sure all the words in our dictionary
        # are stripped of whitespace, and all upper case,
        # for consistency in checking
        return word.strip().upper()
    return None
{% endhighlight %}

Now when we implement our `create_dictionary()` function, we can make use of a Python built-in function called [`map`](https://docs.python.org/3/library/functions.html#map). I have not yet written an exercise specifically about this function, so I'll briefly touch on it here. The purpose of `map` is to apply the same function on any iterable (list, dictionary, set) and return a new version of that iterable with the function applied. In our case this works out perfectly: what we want to do is take in a list of words that we loaded from a text file, and we want to make them all uppercase. More specifically, we want to apply our `filter_word` function to each element of the dictionary.

{% highlight python %}
def create_dictionary(fname: str, length: int) -> typing.List[str]:
    """Load and create a dictionary from a filename."""
    dictionary = set()
    with open(fname, "r") as f:
        lines = f.readlines()
        dictionary = set(map(lambda word: filter_word(word, length), lines))
    return list(dictionary)
{% endhighlight %}

The end result is that when we call the `create_dictionary()` function on our word list, it converts all the words properly to upper case and filters out any undesirable words.

At this point we are ready to put it all together!

## Putting it All Together

Now we just add a few bells and whistles to the text of what the user sees during gameplay (the number of guesses taken, for example), and voila! We have a full Wordle implementation in Python!

{% highlight python %}
"""An implementation of Wordle in Python."""
import random
import typing


GAMEWORD_LIST_FNAME = "gamewords.txt"
GUESSWORD_LIST_FNAME = "guesswords.txt"


def filter_word(word: str, length: int) -> str:
    """Filter a word to add it to the dictionary."""
    if len(word.strip()) == length:
        # make sure all the words in our dictionary
        # are stripped of whitespace, and all upper case,
        # for consistency in checking
        return word.strip().upper()
    return None


def create_dictionary(fname: str, length: int) -> typing.List[str]:
    """Load and create a dictionary from a filename."""
    dictionary = set()
    with open(fname, "r") as f:
        lines = f.readlines()
        dictionary = set(map(lambda word: filter_word(word, length), lines))
    return list(dictionary)


def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
    # make sure the guess is all upper case. but don't modify
    # the passed-in guess, since Python input variables are global
    guess_upper = guess.upper()
    # guesses must be the same as the input word
    if len(guess_upper) != wordlen:
        return f"Guess must be of length {wordlen}", guess_upper

    # guesses must also be words from the word list
    if guess_upper not in dictionary:
        return "Guess must be a valid word", guess_upper
    return None, guess_upper


def get_user_guess(wordlen: int, dictionary: list) -> str:
    """Get a user guess input, validate, and return the guess."""
    # continue looping until you get a valid guess
    while True:
        guess = input("Guess: ")
        # here we overwrite guess with
        # the filtered guess
        error, guess = validate(guess=guess, wordlen=wordlen,
                                dictionary=dictionary)
        if error is None:
            break

        # show the input error to the user, as appropriate
        print(error)
    return guess


def find_all_char_positions(word: str, char: str) -> typing.List[int]:
    """Given a word and a character, find all the indices of that character."""
    positions = []
    pos = word.find(char)
    while pos != -1:
        positions.append(pos)
        pos = word.find(char, pos + 1)
    # make sure the positions are all sorted lowest
    # to highest when this function returns
    return sorted(positions)


# test cases for find_all_char_positions
# find_all_char_positions("steer", "e") => [2, 3]
# find_all_char_positions("steer", "t") => [1]
# find_all_char_positions("steer", "q") => []


def compare(correct: str, guess: str) -> typing.List[str]:
    """Compare the guess with the correct word and return the output parse."""
    # the output is assumed to be incorrect to start,
    # and as we progress through the checking, update
    # each position in our output list
    output = ["_"] * len(correct)
    counted_pos = set()

    # first we check for correct words in the correct positions
    # and update the output accordingly
    for index, (correct_char, guess_char) in enumerate(zip(correct, guess)):
        if correct_char == guess_char:
            # a correct character in the correct position
            output[index] = "*"
            counted_pos.add(index)

    # now we check for the remaining letters that are in incorrect
    # positions. in this case, we need to make sure that if the
    # character that this is correct for was already
    # counted as a correct character, we do NOT display
    # this in the double case. e.g. if the correct word
    # is "steer" but we guess "stirs", the second "S"
    # should display "_" and not "-", since the "S" where
    # it belongs was already displayed correctly
    # likewise, if the guess word has two letters in incorrect
    # places, only the first letter is displayed as a "-".
    # e.g. if the guess is "floss" but the game word is "steer"
    # then the output should be "_ _ _ - _"; the second "s" in "floss"
    # is not displayed.
    for index, guess_char in enumerate(guess):
        # if the guessed character is in the correct word,
        # we need to check the other conditions. the easiest
        # one is that if we have not already guessed that
        # letter in the correct place. if we have, don't
        # double-count
        if guess_char in correct and \
                output[index] != "*":
            # first, what are all the positions the guessed
            # character is present in
            positions = find_all_char_positions(word=correct, char=guess_char)
            # have we accounted for all the positions
            for pos in positions:
                # if we have not accounted for the correct
                # position of this letter yet
                if pos not in counted_pos:
                    output[index] = "-"
                    counted_pos.add(pos)
                    # we only count the "correct letter" once,
                    # so we break out of the "for pos in positions" loop
                    break
    # return the list of parses
    return output


# test cases for comparing
# compare("steer", "stirs") -> "* * _ - _"
# compare("steer", "floss") -> "_ _ _ - _"
# compare("pains", "stirs") -> "_ _ * _ *"
# compare("creep", "enter") -> "- _ _ * -"
# compare("crape", "enter") -> "- _ _ _ -"
# compare("ennui", "enter") -> "* * _ _ _"


if __name__ == '__main__':
    # the game word is 5 letters
    WORDLEN = 5
    # load the wordlist that we will select words from
    # for the wordle game
    GAMEWORD_DICTIONARY = create_dictionary(
        GAMEWORD_LIST_FNAME, length=WORDLEN)

    # load the wordlist for the guesses
    GUESSWORD_DICTIONARY = create_dictionary(
        GUESSWORD_LIST_FNAME, length=WORDLEN)

    # select a random word to start with
    WORD = random.choice(GAMEWORD_DICTIONARY)
    GAME_WORD_LENGTH = len(WORD)

    # keep track of some game state
    NUM_GUESSES = 0

    # print the game instructions to the user
    print("""
Guess words one at a time to guess the game word.

A * character means a letter was guessed correctly
in the correct position.
A - character means a letter was guessed correctly,
but in the incorrect position.

To quit, press CTRL-C.
""")

    # start of the user name interaction
    print("_ " * GAME_WORD_LENGTH)

    # we use a continuous loop, since there could be a number
    # of different exit conditions from the game if we want
    # to spruce it up.
    try:
        while True:
            # get the user to guess something
            GUESS = get_user_guess(
                wordlen=GAME_WORD_LENGTH, dictionary=GUESSWORD_DICTIONARY)
            NUM_GUESSES += 1

            # display the guess when compared against the game word
            result = compare(correct=WORD, guess=GUESS)
            print(" ".join(result))

            if WORD == GUESS:
                print(f"You won! It took you {NUM_GUESSES} guesses.")
                break
    except KeyboardInterrupt:
        print(f"""
You quit - the correct answer was {WORD.upper()}
and you took {NUM_GUESSES} guesses
""")
{% endhighlight %}

## Watch Me Code!

As part of writing this post, I actually coded Wordle myself and recorded it! This is my first time recording myself coding, and I wasn't sure how it will go. Originally I had intended to add audio commentary, but it turns out that it's easier for me to code naturally without talking out loud (or it happens too infrequently to be interesting to others). So instead, there is a video of me live-coding a Wordle clone without any audio. Please find it here:



If this is a format people are interested in, I will keep doing this with other projects and exercises. I am also considering creating a series of audio-visual live-coding answers to the exercises posted on this blog. If this is something that interests you, please let me know in the comments!
