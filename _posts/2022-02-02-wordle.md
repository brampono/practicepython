---
layout: post
title: A Python Wordle Clone
categories: [blog]
---

When learning how to program, I always recommend having a project or application in mind. For me, it makes it easier to concentrate and learn specific skills and flex the critical thinking muscle. What better project to attempt than the latest game craze, [Wordle](https://www.powerlanguage.co.uk/wordle/)? In this post-essay, I'll take you through the steps required to write your own version of Wordle on the command-line.

To make it even more fun (and of course, a tad embarassing for me), I screen-captured myself programming wordle, unedited, for those interested in watching.

<!--more-->

## Structure

This post-essay will take you through the steps and components required to program a Worldle clone in Python (on the command-line, without a GUI), and we'll use this as a use case for what is required to build a medium-sized project. Some parts will be quite boring (for example, planning and gathering requirements), but I hope to use this as a use case to showcase what kinds of work software developers do every day.

First, we'll go through the requirements of our project (the Wordle clone) and put them into a list. Next, we'll tackle each item one by one.

## Requirements

Before starting any programming project, it is important to make a list of all the features you want it to have. This accomplishes two things: (1) gives you a "stopping point" to know when you're done, and (2) lets you organize your thoughts to make sure your choices for how to implement cover all your use cases.

In our case, for a Python command-line clone of Wordle, here is our requirements and features list:

### Gameplay

* Game randomly selects a single 5-letter word from a word list to use as the "game word".
* The word length is taken from the game word, rather than being hard-coded at 5 letters.
* Command-line display asking player to enter guesses.
* A guess is only valid if it is the same length as the game word.
* All guesses should come from a word list. If the guess is not from the list, tell the player, and don't accept the word as part of the number of guesses.
* The player can enter words either in capital or lowercase.
* To quit the game early, the player should press CTRL-C. _The reasoning behind this choice (rather than, for example, having the player type "quit" or "Q") is that CTRL-C can never be a guessed word, whereas "quit" can be. This means that modifying the game to work with 4-letter words does not break the core game play._
* The game will keep track of how many guesses the player has done and display that at the end, either when the word is guessed or when the game is quit.

### Rules

* A guessed letter that is correct and in the correct place displays a `*`.
* A guessed letter that is correct but in the incorrect place displays a `-`.
* All other guessed letters are returned with a blank `_`.
* When the game word has two of the same letter, but the guessed word has one of that letter, it follows the rules for correct and incorrect placement.
* Correctly guessed letters in the correct place are displayed first.
* If the game word has one of a letter, but the guessed word has two, both in the wrong place, only the first letter in the guessed word is displayed as `-`.
* If the game word has one of a letter, but the guessed word has two, one in the correct place, the correct letter is displayed as `*` and the second copy of the letter is unmarked.

## Basic Design

For any command-line game, the basic program structure is a large infinite `while` loop that keeps "playing the game" until an end condition is met. According to our requirements list, the end conditions are:

1. The player guesses the word correctly.
2. The player exits by pressing CTRL-C.

So the first step is to structure our program with this basic scaffold (in a `__main__` block). First we tackle the first condition. We don't deal with selecting the word or processing guesses, so we create two dummy variables (`WORD` and `GUESS`), set them to specific strings, and continue adding on later.

{% highlight python %}
if __name__ == '__main__':
  WORD = "TESTS"
  while True:
    GUESS = "PHONE"
    if WORD == GUESS:
      print("You won!")
      break
{% endhighlight %}

Now we can add in the second end condition (exit on CTRL-C). This is slightly more complicated, since in Python the way to catch a CTRL-C press is through a `KeyboardInterrupt` exception, so we wrap the existing loop in a `try`/`catch` to catch the CTRL-C.

{% highlight python %}
if __name__ == '__main__':
  WORD = "TESTS"

  try:
    while True:
      GUESS = "PHONE"
      if WORD == GUESS:
        print("You won!")
        break
  except KeyboardInterrupt:
    print("You exited the game.")
{% endhighlight %}

Now that we have the structure of the main loop, we can add in the mechanics for player interaction, namely, taking player guesses.

## Player Guesses

One feature of the game play is that we need some error checking / handling on a player's guesses. Because this is a functionality that can be independently tested and verified, processing and getting a user guess is a great candidate for putting inside of a function. The heading of this function will look like this:

{% highlight python %}
def get_user_guess(wordlen: int, dictionary: list[str]) -> str:
    """Get a user guess input, validate, and return the guess."""
{% endhighlight %}

The type annotation is natively supported in Python 3, as seen in the [official documentation for the `typing` library](https://docs.python.org/3.9/library/typing.html). What our function signature tells us is that the function is going to get the user guess. It takes in two inputs: (1) the length of the expected game word (which is an int), and (2) the list of available guess words as strings. The function will return a single string, which is the player's guess. Because we return the string of the guess from this function, all the logic around validating a guess, displaying to the player why the guess is in valid, and asking the user to input a new guess, is contained in this function. Because we are potentially in a situation where we need to ask the user multiple times to enter a guess (if for example they keep entering a 4-letter word when the game word is 5 letters), we use another `while` loop here for the structure.

{% highlight python %}
def get_user_guess(wordlen: int, dictionary: list[str]) -> str:
    """Get a user guess input, validate, and return the guess."""
    # continue looping until you get a valid guess
    while True:
        guess = input("Guess: ")
        # here we overwrite guess with
        # the filtered guess
        error, guess = validate(guess=guess, wordlen=wordlen,
                                dictionary=dictionary)

        # if there wasn't an error with the guess, we stop asking
        # the user for new guesses
        if error is None:
            break

        # show the input error to the user, as appropriate
        print(error)
    return guess
{% endhighlight %}

The choice I've made here is to abstract the "validation" logic into yet another function. This is because validating a guess is a repeatable action we take on a word that can be independently tested. Let's write that validation function now:

{% highlight python %}
def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
{% endhighlight %}

Our validation function header will validate a guess according to any validation rules we want. It takes in a guess as a string (any string), the expected length of the game word, and the list of possible game words. What the validation function returns is a tuple containing the error and the guess word. If there is no error, `None` is returned for the error. This is again a design choice - some programmers will not return the guess word back, and rely on the fact that if `None` is returned for the error, the initial guess word is fine. However, the choice here of returning the guess word is a form of filtering & validation. Because we listed in the requirements that guesses can be entered in uppercase or lower case, we want to standardize all the guesses into uppercase. This means that somewhere we will have to convert the guess into all uppercase letters. What better place to do this than the same function where we are validating our guesses?

The implementation of the function then looks like this:

{% highlight python %}
def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
    # make sure the guess is all upper case. but don't modify
    # the passed-in guess, since Python input variables are global
    guess_upper = guess.upper()
    # guesses must be the same as the input word
    if len(guess_upper) != wordlen:
        return f"Guess must be of length {wordlen}", guess_upper

    # guesses must also be words from the word list
    if guess_upper not in dictionary:
        return "Guess must be a valid word", guess_upper
    return None, guess_upper
{% endhighlight %}

Note that all the return statements return a tuple: the first argument is an error string (or `None` if we get all the way to the end), and the guess converted into uppercase.

Of note: Python variables are passed _by reference_, which means that if an input argument to a function is modified, the variable that is passed in is also modified. This can have unintended consequences for the code that is calling a function, so to prevent any side effects on the calling code, we convert the `guess` variable to uppercase and store it in a new variable called `guess_upper`, rather than doing `guess = guess.upper()`.

Now that we have a validation function, a user input function, and a main loop, our code so far looks like:

{% highlight python %}
import typing


def validate(guess: str, wordlen: int,
             dictionary: list) -> typing.Tuple[str, str]:
    """
    Validate a guess from a user.

    Return tuple of [None if no error or a string containing
    the error message, the guess].
    """
    # make sure the guess is all upper case. but don't modify
    # the passed-in guess, since Python input variables are global
    guess_upper = guess.upper()
    # guesses must be the same as the input word
    if len(guess_upper) != wordlen:
        return f"Guess must be of length {wordlen}", guess_upper

    # guesses must also be words from the word list
    if guess_upper not in dictionary:
        return "Guess must be a valid word", guess_upper
    return None, guess_upper


def get_user_guess(wordlen: int, dictionary: list[str]) -> str:
    """Get a user guess input, validate, and return the guess."""
    # continue looping until you get a valid guess
    while True:
        guess = input("Guess: ")
        # here we overwrite guess with
        # the filtered guess
        error, guess = validate(guess=guess, wordlen=wordlen,
                                dictionary=dictionary)

        # if there wasn't an error with the guess, we stop asking
        # the user for new guesses
        if error is None:
            break

        # show the input error to the user, as appropriate
        print(error)
    return guess

if __name__ == '__main__':
  WORD = "TESTS"
  GAME_WORD_LENGTH = len(WORD)
  GUESS_DICTIONARY = [WORD, "GAMES", "FRONT", "TILES"]

  try:
    while True:
      GUESS = get_user_guess(GAME_WORD_LENGTH, GUESS_DICTIONARY)

      if WORD == GUESS:
        print("You won!")
        break
  except KeyboardInterrupt:
    print("You exited the game.")
{% endhighlight %}

At this point, we have a game where player input is continually read and validated! Next up, displaying information back to the player so the game is actually fun!

## Displaying Guesses

